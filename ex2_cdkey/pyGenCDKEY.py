#!/usr/bin/env python3
# * PROGRAMA EM PYTHON 3 PARA VALIDAR A CDKEY DE UM SOFTWARE
# * 
# * Este programa foi desenvolvido em C originalmente, e adaptado para 
# * Python para demonstrar o algoritmo de validacao da CDKEY de um software.
# *
# * Para executar o script (em qualquer ambiente):
# *      python3 pyGenCDKEY.py
#
import os
import sys
import struct
import string 
import random

# * Caso queira acompanhar as mensagens de DEBUG, e visualizar
# * passo a passo a execucao do programa, altere o valor da
# * variavel DEBUG para True.
DEBUG = False

# * Para extrair o BUFFER necessario (para XOR dos bytes),
# * use o comando abaixo na linha de comando do radare2.
# * ADAPTADO PARA PYTHON:
# *
# * RADARE2:> pcp 1024 @ 0x100dd000
bufferData = [
	0x00, 0x00, 0x00, 0x00, 0x96, 0x30, 0x07, 0x77, 0x2c, 0x61,
	0x0e, 0xee, 0xba, 0x51, 0x09, 0x99, 0x19, 0xc4, 0x6d, 0x07,
	0x8f, 0xf4, 0x6a, 0x70, 0x35, 0xa5, 0x63, 0xe9, 0xa3, 0x95,
	0x64, 0x9e, 0x32, 0x88, 0xdb, 0x0e, 0xa4, 0xb8, 0xdc, 0x79,
	0x1e, 0xe9, 0xd5, 0xe0, 0x88, 0xd9, 0xd2, 0x97, 0x2b, 0x4c,
	0xb6, 0x09, 0xbd, 0x7c, 0xb1, 0x7e, 0x07, 0x2d, 0xb8, 0xe7,
	0x91, 0x1d, 0xbf, 0x90, 0x64, 0x10, 0xb7, 0x1d, 0xf2, 0x20,
	0xb0, 0x6a, 0x48, 0x71, 0xb9, 0xf3, 0xde, 0x41, 0xbe, 0x84,
	0x7d, 0xd4, 0xda, 0x1a, 0xeb, 0xe4, 0xdd, 0x6d, 0x51, 0xb5,
	0xd4, 0xf4, 0xc7, 0x85, 0xd3, 0x83, 0x56, 0x98, 0x6c, 0x13,
	0xc0, 0xa8, 0x6b, 0x64, 0x7a, 0xf9, 0x62, 0xfd, 0xec, 0xc9,
	0x65, 0x8a, 0x4f, 0x5c, 0x01, 0x14, 0xd9, 0x6c, 0x06, 0x63,
	0x63, 0x3d, 0x0f, 0xfa, 0xf5, 0x0d, 0x08, 0x8d, 0xc8, 0x20,
	0x6e, 0x3b, 0x5e, 0x10, 0x69, 0x4c, 0xe4, 0x41, 0x60, 0xd5,
	0x72, 0x71, 0x67, 0xa2, 0xd1, 0xe4, 0x03, 0x3c, 0x47, 0xd4,
	0x04, 0x4b, 0xfd, 0x85, 0x0d, 0xd2, 0x6b, 0xb5, 0x0a, 0xa5,
	0xfa, 0xa8, 0xb5, 0x35, 0x6c, 0x98, 0xb2, 0x42, 0xd6, 0xc9,
	0xbb, 0xdb, 0x40, 0xf9, 0xbc, 0xac, 0xe3, 0x6c, 0xd8, 0x32,
	0x75, 0x5c, 0xdf, 0x45, 0xcf, 0x0d, 0xd6, 0xdc, 0x59, 0x3d,
	0xd1, 0xab, 0xac, 0x30, 0xd9, 0x26, 0x3a, 0x00, 0xde, 0x51,
	0x80, 0x51, 0xd7, 0xc8, 0x16, 0x61, 0xd0, 0xbf, 0xb5, 0xf4,
	0xb4, 0x21, 0x23, 0xc4, 0xb3, 0x56, 0x99, 0x95, 0xba, 0xcf,
	0x0f, 0xa5, 0xbd, 0xb8, 0x9e, 0xb8, 0x02, 0x28, 0x08, 0x88,
	0x05, 0x5f, 0xb2, 0xd9, 0x0c, 0xc6, 0x24, 0xe9, 0x0b, 0xb1,
	0x87, 0x7c, 0x6f, 0x2f, 0x11, 0x4c, 0x68, 0x58, 0xab, 0x1d,
	0x61, 0xc1, 0x3d, 0x2d, 0x66, 0xb6, 0x90, 0x41, 0xdc, 0x76,
	0x06, 0x71, 0xdb, 0x01, 0xbc, 0x20, 0xd2, 0x98, 0x2a, 0x10,
	0xd5, 0xef, 0x89, 0x85, 0xb1, 0x71, 0x1f, 0xb5, 0xb6, 0x06,
	0xa5, 0xe4, 0xbf, 0x9f, 0x33, 0xd4, 0xb8, 0xe8, 0xa2, 0xc9,
	0x07, 0x78, 0x34, 0xf9, 0x00, 0x0f, 0x8e, 0xa8, 0x09, 0x96,
	0x18, 0x98, 0x0e, 0xe1, 0xbb, 0x0d, 0x6a, 0x7f, 0x2d, 0x3d,
	0x6d, 0x08, 0x97, 0x6c, 0x64, 0x91, 0x01, 0x5c, 0x63, 0xe6,
	0xf4, 0x51, 0x6b, 0x6b, 0x62, 0x61, 0x6c, 0x1c, 0xd8, 0x30,
	0x65, 0x85, 0x4e, 0x00, 0x62, 0xf2, 0xed, 0x95, 0x06, 0x6c,
	0x7b, 0xa5, 0x01, 0x1b, 0xc1, 0xf4, 0x08, 0x82, 0x57, 0xc4,
	0x0f, 0xf5, 0xc6, 0xd9, 0xb0, 0x65, 0x50, 0xe9, 0xb7, 0x12,
	0xea, 0xb8, 0xbe, 0x8b, 0x7c, 0x88, 0xb9, 0xfc, 0xdf, 0x1d,
	0xdd, 0x62, 0x49, 0x2d, 0xda, 0x15, 0xf3, 0x7c, 0xd3, 0x8c,
	0x65, 0x4c, 0xd4, 0xfb, 0x58, 0x61, 0xb2, 0x4d, 0xce, 0x51,
	0xb5, 0x3a, 0x74, 0x00, 0xbc, 0xa3, 0xe2, 0x30, 0xbb, 0xd4,
	0x41, 0xa5, 0xdf, 0x4a, 0xd7, 0x95, 0xd8, 0x3d, 0x6d, 0xc4,
	0xd1, 0xa4, 0xfb, 0xf4, 0xd6, 0xd3, 0x6a, 0xe9, 0x69, 0x43,
	0xfc, 0xd9, 0x6e, 0x34, 0x46, 0x88, 0x67, 0xad, 0xd0, 0xb8,
	0x60, 0xda, 0x73, 0x2d, 0x04, 0x44, 0xe5, 0x1d, 0x03, 0x33,
	0x5f, 0x4c, 0x0a, 0xaa, 0xc9, 0x7c, 0x0d, 0xdd, 0x3c, 0x71,
	0x05, 0x50, 0xaa, 0x41, 0x02, 0x27, 0x10, 0x10, 0x0b, 0xbe,
	0x86, 0x20, 0x0c, 0xc9, 0x25, 0xb5, 0x68, 0x57, 0xb3, 0x85,
	0x6f, 0x20, 0x09, 0xd4, 0x66, 0xb9, 0x9f, 0xe4, 0x61, 0xce,
	0x0e, 0xf9, 0xde, 0x5e, 0x98, 0xc9, 0xd9, 0x29, 0x22, 0x98,
	0xd0, 0xb0, 0xb4, 0xa8, 0xd7, 0xc7, 0x17, 0x3d, 0xb3, 0x59,
	0x81, 0x0d, 0xb4, 0x2e, 0x3b, 0x5c, 0xbd, 0xb7, 0xad, 0x6c,
	0xba, 0xc0, 0x20, 0x83, 0xb8, 0xed, 0xb6, 0xb3, 0xbf, 0x9a,
	0x0c, 0xe2, 0xb6, 0x03, 0x9a, 0xd2, 0xb1, 0x74, 0x39, 0x47,
	0xd5, 0xea, 0xaf, 0x77, 0xd2, 0x9d, 0x15, 0x26, 0xdb, 0x04,
	0x83, 0x16, 0xdc, 0x73, 0x12, 0x0b, 0x63, 0xe3, 0x84, 0x3b,
	0x64, 0x94, 0x3e, 0x6a, 0x6d, 0x0d, 0xa8, 0x5a, 0x6a, 0x7a,
	0x0b, 0xcf, 0x0e, 0xe4, 0x9d, 0xff, 0x09, 0x93, 0x27, 0xae,
	0x00, 0x0a, 0xb1, 0x9e, 0x07, 0x7d, 0x44, 0x93, 0x0f, 0xf0,
	0xd2, 0xa3, 0x08, 0x87, 0x68, 0xf2, 0x01, 0x1e, 0xfe, 0xc2,
	0x06, 0x69, 0x5d, 0x57, 0x62, 0xf7, 0xcb, 0x67, 0x65, 0x80,
	0x71, 0x36, 0x6c, 0x19, 0xe7, 0x06, 0x6b, 0x6e, 0x76, 0x1b,
	0xd4, 0xfe, 0xe0, 0x2b, 0xd3, 0x89, 0x5a, 0x7a, 0xda, 0x10,
	0xcc, 0x4a, 0xdd, 0x67, 0x6f, 0xdf, 0xb9, 0xf9, 0xf9, 0xef,
	0xbe, 0x8e, 0x43, 0xbe, 0xb7, 0x17, 0xd5, 0x8e, 0xb0, 0x60,
	0xe8, 0xa3, 0xd6, 0xd6, 0x7e, 0x93, 0xd1, 0xa1, 0xc4, 0xc2,
	0xd8, 0x38, 0x52, 0xf2, 0xdf, 0x4f, 0xf1, 0x67, 0xbb, 0xd1,
	0x67, 0x57, 0xbc, 0xa6, 0xdd, 0x06, 0xb5, 0x3f, 0x4b, 0x36,
	0xb2, 0x48, 0xda, 0x2b, 0x0d, 0xd8, 0x4c, 0x1b, 0x0a, 0xaf,
	0xf6, 0x4a, 0x03, 0x36, 0x60, 0x7a, 0x04, 0x41, 0xc3, 0xef,
	0x60, 0xdf, 0x55, 0xdf, 0x67, 0xa8, 0xef, 0x8e, 0x6e, 0x31,
	0x79, 0xbe, 0x69, 0x46, 0x8c, 0xb3, 0x61, 0xcb, 0x1a, 0x83,
	0x66, 0xbc, 0xa0, 0xd2, 0x6f, 0x25, 0x36, 0xe2, 0x68, 0x52,
	0x95, 0x77, 0x0c, 0xcc, 0x03, 0x47, 0x0b, 0xbb, 0xb9, 0x16,
	0x02, 0x22, 0x2f, 0x26, 0x05, 0x55, 0xbe, 0x3b, 0xba, 0xc5,
	0x28, 0x0b, 0xbd, 0xb2, 0x92, 0x5a, 0xb4, 0x2b, 0x04, 0x6a,
	0xb3, 0x5c, 0xa7, 0xff, 0xd7, 0xc2, 0x31, 0xcf, 0xd0, 0xb5,
	0x8b, 0x9e, 0xd9, 0x2c, 0x1d, 0xae, 0xde, 0x5b, 0xb0, 0xc2,
	0x64, 0x9b, 0x26, 0xf2, 0x63, 0xec, 0x9c, 0xa3, 0x6a, 0x75,
	0x0a, 0x93, 0x6d, 0x02, 0xa9, 0x06, 0x09, 0x9c, 0x3f, 0x36,
	0x0e, 0xeb, 0x85, 0x67, 0x07, 0x72, 0x13, 0x57, 0x00, 0x05,
	0x82, 0x4a, 0xbf, 0x95, 0x14, 0x7a, 0xb8, 0xe2, 0xae, 0x2b,
	0xb1, 0x7b, 0x38, 0x1b, 0xb6, 0x0c, 0x9b, 0x8e, 0xd2, 0x92,
	0x0d, 0xbe, 0xd5, 0xe5, 0xb7, 0xef, 0xdc, 0x7c, 0x21, 0xdf,
	0xdb, 0x0b, 0xd4, 0xd2, 0xd3, 0x86, 0x42, 0xe2, 0xd4, 0xf1,
	0xf8, 0xb3, 0xdd, 0x68, 0x6e, 0x83, 0xda, 0x1f, 0xcd, 0x16,
	0xbe, 0x81, 0x5b, 0x26, 0xb9, 0xf6, 0xe1, 0x77, 0xb0, 0x6f,
	0x77, 0x47, 0xb7, 0x18, 0xe6, 0x5a, 0x08, 0x88, 0x70, 0x6a,
	0x0f, 0xff, 0xca, 0x3b, 0x06, 0x66, 0x5c, 0x0b, 0x01, 0x11,
	0xff, 0x9e, 0x65, 0x8f, 0x69, 0xae, 0x62, 0xf8, 0xd3, 0xff,
	0x6b, 0x61, 0x45, 0xcf, 0x6c, 0x16, 0x78, 0xe2, 0x0a, 0xa0,
	0xee, 0xd2, 0x0d, 0xd7, 0x54, 0x83, 0x04, 0x4e, 0xc2, 0xb3,
	0x03, 0x39, 0x61, 0x26, 0x67, 0xa7, 0xf7, 0x16, 0x60, 0xd0,
	0x4d, 0x47, 0x69, 0x49, 0xdb, 0x77, 0x6e, 0x3e, 0x4a, 0x6a,
	0xd1, 0xae, 0xdc, 0x5a, 0xd6, 0xd9, 0x66, 0x0b, 0xdf, 0x40,
	0xf0, 0x3b, 0xd8, 0x37, 0x53, 0xae, 0xbc, 0xa9, 0xc5, 0x9e,
	0xbb, 0xde, 0x7f, 0xcf, 0xb2, 0x47, 0xe9, 0xff, 0xb5, 0x30,
	0x1c, 0xf2, 0xbd, 0xbd, 0x8a, 0xc2, 0xba, 0xca, 0x30, 0x93,
	0xb3, 0x53, 0xa6, 0xa3, 0xb4, 0x24, 0x05, 0x36, 0xd0, 0xba,
	0x93, 0x06, 0xd7, 0xcd, 0x29, 0x57, 0xde, 0x54, 0xbf, 0x67,
	0xd9, 0x23, 0x2e, 0x7a, 0x66, 0xb3, 0xb8, 0x4a, 0x61, 0xc4,
	0x02, 0x1b, 0x68, 0x5d, 0x94, 0x2b, 0x6f, 0x2a, 0x37, 0xbe,
	0x0b, 0xb4, 0xa1, 0x8e, 0x0c, 0xc3, 0x1b, 0xdf, 0x05, 0x5a,
	0x8d, 0xef, 0x02, 0x2d
]

# * DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG
# * DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG
# Para melhor visualizacao de algum elemento do BUFFER, use a funcao
# abaixo. Funcao util apenas para DEBUG do codigo.
def ImprimaByte(argPosicao):
	print("bufferData[" + str(argPosicao) + "]: " + hex(bufferData[argPosicao]))

# Funcao para imprimir, byte a byte, cada item do BUFFER. 
# Funcao util apenas para DEBUG do codigo.
def ImprimaBufferCompleto():
	for i in range(len(bufferData)):
		ImprimaByte(i)

# * ========================================================================
# A funcao a seguir nao existe originalmente, nem no codigo analisado, nem no
# script em C. Essa funcao eh necessaria somente em Python, para transformar/ 
# converter um byte (8 bits), em um valor de 4 bytes (32 bits), com base nos 
# bytes do BUFFERDATA.
#
# A tecnica utilizada em C eh nativa da linguagem C:
# a conversao da variavel, declarada anteriormente como sendo (uint8_t) em
# um valor inteiro de 32 bits (uint32_t) pode ser, e eh feita assim:
#        varResultador = ...... *(uint32_t *)((rcR1*4) + bufferData)
# 
# Em Python, contudo, precisamos adaptar a forma com que a PILHA (stack) 
# eh construida.
# Para mais informacoes sobre isso, veja a funcao ValidaKey, na linha onde
# a funcao TransformaUint32 eh chamada.
#
# A ideia base dessa funcao surgiu, depois de MUITA PESQUISA, do seguinte post:
#  https://stackoverflow.com/questions/22204142/how-to-append-a-list-of-hex-to-one-hex-number
def TransformaUint32(argByteResultador):
	# Criamos uma LISTA para ser usada na funcao.
	tmpArray = []

	# Queremos armazenar o byte da posicao atual em bufferData,
	# e tambem os 3 bytes restantes para completar 4 bytes, por exemplo:
	#    0x04030201
	#   ou
	#    0x BUFFERDATA[byte+0x03]  BUFFERDATA[byte+0x02]  BUFFERDATA[byte+0x01]  BUFFERDATA[byte]
	# Somando 4 bytes (32 bits) em um hexadecimal, e
	# simulando uma PILHA (STACK), "ultimo byte eh o primeiro".
	tmpArray.append(bufferData[argByteResultador])
	tmpArray.append(bufferData[(argByteResultador) + 0x01])
	tmpArray.append(bufferData[(argByteResultador) + 0x02])
	tmpArray.append(bufferData[(argByteResultador) + 0x03])
	
	# A linha principal da funcao, onde encadeamos cada um dos bytes de tmpArray em
	# uma cadeia unica de BYTES.
	arrBytes = bytes.fromhex(''.join([format(int(hex(c), 16), '02X') for c in tmpArray]))

	# Precisamos limpar a array
	tmpArray.clear()

	# E agora, recuperamos e transformamos a LIST de BYTES em um valor inteiro final.
	hexaUint32 = struct.unpack('<I', arrBytes)[0]

	# E pronto! funcao retorna o valor inteiro, de 4bytes.
	return hexaUint32

# * A funcao ValidaKey 'e utilizada para calcular, byte a byte,
# * o valor hexadecimal que sera utilizado na segunda etapa do
# * algoritmo. Chamaremos este valor final de "verificador".
# *
# * Nesta funcao, 'e necessaria apenas a primeira parte da CDKEY.
# * Os dois ultimos digitos da CDKEY serao calculados e recuperados
# * na funcao VerificaKey, com o retorno na variavel 
# * resultadoVerificador.
def ValidaKey(argKey1):
	if DEBUG:
		print(f" _ DEBUG: Testando CDKEY {argKey1}.\n")

	# * DESCRICAO: recupera o valor da CDKEY_1 e atribui a
	# * uma variavel.
	# *
	# * CODIGO ASSEMBLY (ASM):
	# * OFFSET    : INSTRUCAO
	# * 0x1000160e: mov dword [varResultador], 0xffffffff;
	varResultador = 0xffffffff

	# Para cada BYTE na cadeia de BYTES da primeira parte da CDKEY.
	for thisByte in argKey1:
		# * ASM:
		# * 0x1000162c: mov edx, dword [varResultador]
		# * 0x1000162f: xor edx, ecx
		# * 0x10001631: and edx, 0xff
		rcR1 = ((varResultador ^ thisByte) & 0xFF)

		# * ASM:
		# * 0x10001637: mov eax, dword [varResultador]
		# * 0x1000163a: shr eax, 8
		rcR2 = varResultador >> 8

		# * DESC.: este bloco de instrucoes talvez seja a parte mais dificil
		# * de entender, de todo o codigo, devido as acoes que sao executadas
		# * pelo processador.
		# *
		# * Em resumo, a varResultador recebera o valor, unsigned int32, de 
		# * bufferData[rcR1*4] XORed com rcR2.
		# *
		# * Em ASM, encontramos a instrucao "dword[edx*4 + bufferData]". Para 
		# * essa instrucao, o codigo (variavel + array), em C, equivale a 
		# * acessar o indice da array: array[variavel].
		# *
		# * Dessa forma, podemos escrever o seguinte codigo:
		# *      varResultador = ( rcR2 ^ *(uint32_t *)&bufferData[rcR1*4] );
		# *
		# * DICA: Para entender melhor, ative o DEBUG e visualize as mensagens.
		# *
		# * Ilustrando, um exemplo com valores:
		# *  - Sendo a variavel rcR1 = 0x000000BE;
		# *  - Sendo (rcR1*4) = 0x000002f8 (ou 760 em decimal);
		# *
		# *  - Portanto, (0x2F8+bufferData) == bufferData[0x2F8]:
		# *  -- bufferData[0x2F8], na posicao 0x2F8 (760) de bufferData, encontramos 
		# *  o byte com valor 0x8B. Assim, bufferData[0x2F8] equivale a 0x8B.
		# *  
		# *  - Entao, nas etapas seguintes, realizamos o cast (conversao) de 
		# *  bufferData[0x2F8], de unsigned_int8 (UM byte) para unsigned_int32 (4 bytes).
		# *
		# *  - O resultado ser'a o hexadecimal: 0x2CD99E8B, pois o processador ir'a pegar
		# *  os ultimos bytes da STACK (pilha) para completar os 4 bytes necessarios do
		# *  tipo uint32_t.
		# * --  1 byte em bufferData[0x2F8]: 0x8B
		# * -- +1 byte em bufferData[0x2F9]: 0x9E
		# * -- +1 byte em bufferData[0x2FA]: 0xD9
		# * -- +1 byte em bufferData[0x2FB]: 0x2C
		# *
		# *  Resultado: 0x2CD99E8B.
		# *
		# * ADAPTADO para PYTHON:
		# * O problema em adaptar o codigo em C para Python esta justamente nesse trecho
		# * de codigo. Precisamos de uma funcao, chamada TransformaUint32, para converter
		# * um byte, em quatro bytes sequenciais do Buffer.
		if DEBUG:
			print(f" _ DEBUG: Processando bufferData[{(rcR1*4)}], equivalente ao BYTE {hex(bufferData[rcR1*4])}.");
			print(f" _ DEBUG: O valor de bufferData[{(rcR1*4)}], em uint32_t, eh {hex(TransformaUint32(rcR1*4))}.");

		# * ASM:
		# * 0x1000163d: mov ecx, dword [edx*4 + bufferData]
		# * 0x10001644: xor ecx, eax
		# * 0x10001646: mov dword [varResultador], ecx
		varResultador = ( rcR2 ^ (TransformaUint32(rcR1*4)) )

		if DEBUG:
			print(f" _ DEBUG: Processando caracter o {chr(thisByte)}, hexadecimal {hex(thisByte)}.");

	# * ASM:
	# *.subloc_validaRetorna
	# * 0x10001654: mov eax, dword [varResultador]
	# * 0x10001657: xor eax, 0xffffffff
	return varResultador ^ 0xffffffff

# * A funcao VerificaKey 'e utilizada para a primeira etapa de
# * verificacao sobre a CDKey. Dentro desta funcao, o algoritmo
# * verifica se o tamanho de cada parte da KEY corresponde ao
# * tamanho necessario pelo algoritmo.
# *
# * Em seguida, a VerificaKey chama a funcao ValidaKey que
# * realiza os calculos dos bytes, com apenas a primeira parte
# * da CDKey. Com base neste resultado, novas instrucoes sao
# * executadas para calcular os ultimos digitos (ou segunda
# * parte da CDKey). 
def VerificaKey(argKey1, argKey2):
	# * DESC.: Condicao IF para verificar se a chave informada pelo usuario
	# * corresponde ao tamanho de 16 caracteres da string. A funcao
	# * utilizada pelo algortimo, em C, eh a strlen().
	# * -> size_t *strlen(const char *str)
	# *
	# *  ASM:
	# *  0x10001f7e: mov edx, dword [ptrKey1]
	# *  0x10001f81: add edx, 0x5c
	# *  0x10001f84: push edx
	# *  0x10001f85: call __EXTERNAL_STRLEN
	# *  0x10001f8a: add esp, 4
	# *  0x10001f8d: cmp eax, 0x10
	# *  0x10001f90: jne .subloc_verificaErro
	if (len(argKey1) == 16):
		# ADAPTADO PARA PYTHON
		# Para melhor o programa, em Python, transformamos a string de caracteres
		# da primeira parte da CDKEY, em uma LISTA de BYTES.
		arrBytesKey1 = bytes(argKey1, "UTF-8")

		# * DESC.: Condicao IF para verificar o tamanho da segunda parte da chave
		# * informada pelo usuario que sera comparada ao resultado das operacoes
		# * em resultadoVerificador. 
		# *
		# * ASM:
		# * .subloc_verificaDigitos
		# * 0x10001f92: lea eax, [ptrKey2]
		# * 0x10001f95: push eax
		# * 0x10001f96: call __EXTERNAL_STRLEN
		# * 0x10001f9b: add esp, 4
		# * 0x10001f9e: cmp eax, 2
		# * 0x10001fa1: je .subloc_verificaCalcula
		if (len(argKey2) == 2):
			# * ASM:
			# * .subloc_verificaCalcula:
			# * ...
			# * 0x10001fcf: call fcn.jmp_ValidaKey
			# * 0x10001fd4: add esp, 8
			# * 0x10001fd7: mov dword [resultadorValidaKey], eax
			resultadorValidaKey = ValidaKey(arrBytesKey1)

			if DEBUG:
				print(f" _ DEBUG: Resultado final, retorno da funcao ValidaKey: {hex(resultadorValidaKey)}.");

			# * ASM:
			# * 0x10001fda: mov edx, dword [resultadorValidaKey]
			# * 0x10001fdd: and edx, 0xff
			# * 0x10001fe3: mov eax, dword [resultadorValidaKey]
			# * 0x10001fe6: and eax, 0xff00
			# * 0x10001feb: shr eax, 8
			# * 0x10001fee: mov ecx, dword [resultadorValidaKey]
			# * 0x10001ff1: and ecx, 0xff0000
			# * 0x10001ff7: shr ecx, 0x10
			# * 0x10001ffa: mov esi, dword [resultadorValidaKey]
			# * 0x10001ffd: and esi, 0xff000000
			# * 0x10002003: shr esi, 0x18
			# * 0x10002006: xor ecx, esi
			# * 0x10002008: xor eax, ecx
			# * 0x1000200a: xor edx, eax
			# * 0x1000200c: mov dword [resultadoVerificador], edx
			# *
			# * OBS.: transcrevendo para uma linguagem mais facil,
			# * a ultima parte dos calculos ficara assim:
			# *
			# * resultadoVerificador = (edx) ^ ( eax ^ (ecx ^ esi) )
			# * resultadoVerificador = (edx) ^ ( eax ^ ecx )
			# * resultadoVerificador = (edx) ^ (eax)
			# * resultadoVerificador = (edx)
			resultadorVerificador = (resultadorValidaKey & 0xff) \
										^ ((resultadorValidaKey & 0xff00) >> 0x08) \
										^ ((resultadorValidaKey & 0xff0000) >> 0x10) \
										^ ((resultadorValidaKey & 0xff000000) >> 0x18)

			if DEBUG:
				print(f" _ DEBUG: Resultado verificador (PARTE2 da CDKEY): {format(resultadorVerificador, '02X')}.");

			# * DESC.: As instrucoes a seguir visam formatar o conteudo de
			# * resultadoVerificador em uma variavel (com a funcao sprintf).
			# * Para que entao, seja usada para comparar os resultados 
			# * anteriores.
			# *
			# * ASM:
			# * 0x1000200f: mov edx, dword [resultadoVerificador]
			# * 0x10002012: push edx
			# * 0x10002013: push str._02X
			# * 0x10002018: lea eax, [varhexaDigitos]
			# * 0x1000201b: push eax
			# * 0x1000201c: call __EXTERNAL_SPRINTF
			# * 
			# * ADAPTADO PARA PYTHON
			# * Mudamos a forma com que o resultado final de resultadorVerificador
			# * eh armazenado na variavel varhexaDigitos.
			varhexaDigitos = ('{:02X}'.format(resultadorVerificador))

			# * ADAPTADO PARA PYTHON
			# * Compara a string recebida do usuario (como sendo a segunda parte
			# * da CDKEY), com o resultado em resultadoVerificador (formatado da
			# * maneira apropriada).
			if (argKey2 == varhexaDigitos):
				print(" * RESULTADO: A CDKEY esta CORRETA.\n")
			else:
				print(" * RESULTADO: A CDKEY esta incorreta.\n");
		else:
			print(" * ERRO: CDKey invalida!\n ** Tamanho incorreto da CD_KEY_2.\n")
			sys.exit(1)
	else:
		print(" * ERRO: CDKEY invalida!\n ** Tamanho incorreto da CD_KEY_16.\n")
		sys.exit(1)

# * BONUS BONUS BONUS BONUS BONUS BONUS BONUS
# * BONUS BONUS BONUS BONUS BONUS BONUS BONUS
# *
# * As funcoes a seguir nao estao no arquivo binario original que foi
# * analisado anteriormente. Estas funcoes nao fazem parte do algoritmo
# * de verificacao e validacao da CDKey original.
# *
# * Estas funcoes foram criadas para demonstrar como gerar CDKeys aleatorias
# * com base no algoritmo encontrado anteriormente.
# *
# * 
# * ========================================================================
# *
# *
# *
# * Funcao para gerar uma sequencia aleatoria de caracteres, com base no
# * alfabeto declarado em argAlfabeto. Essa string aleatoria sera utilizada
# * como CDKey. O calculo dos ultimos dois digitos sera realizado pela funcao
# * GerarKeyDigitos.
# *
# * ADAPTADO PARA PYTHON
# * # https://stackoverflow.com/questions/2257441/random-string-generation-with-upper-case-letters-and-digits?rq=1
def GerarKeyRandomica (argTamanho=16, argAlfabeto=string.ascii_uppercase + string.digits):
	return ''.join(random.choice(argAlfabeto) for n in range(argTamanho))

# * A funcao a seguir 'e apenas um trecho da funcao VerificaKey(),
# * onde calcula-se os ultimos digitos da CDKey. Desta forma, pode-se
# * descobrir os ultimos digitos com qualquer string de caracteres
# * gerada anteriormente.
def GerarKeyDigitos(argKey1):
	varhexaDigitos = ""
	if (len(argKey1) == 16):
		arrBytesKey1 = bytes(argKey1, "UTF-8")
		resultadorValidaKey = ValidaKey(arrBytesKey1)

		resultadorVerificador = (resultadorValidaKey & 0xff) \
										^ ((resultadorValidaKey & 0xff00) >> 0x08) \
										^ ((resultadorValidaKey & 0xff0000) >> 0x10) \
										^ ((resultadorValidaKey & 0xff000000) >> 0x18)

		varhexaDigitos = '{:02X}'.format(resultadorVerificador)

	return varhexaDigitos

# * ========================================================================
# * FUNCAO main: a funcao principal recebera os parametros passados
# * na linha de comando. A funcao espera receber duas strings com 16 e 2 caracteres
# * respectivamente. Depois dessas validacoes, as strings serao repassadas para
# * a funcao de verificacao e calculo do algoritmo: VerificaKey() e ValidaKey(). 
if __name__ == "__main__":
	# Armazenamos em argc a quantidade de argumentos passados na linha de comando.
	# Em Python, recebemos sempre 1 parametro: sys.argv[0] que eh o nome do programa.
	argc = len(sys.argv)

	# * Verificando se todos os argumentos foram inseridos na linha de comando.
	# * A variavel "argc" possui a quantidade de argumentos passados ao programa,
	# * inclusive o nome do proprio executavel (sys.argv[0]).
	if (argc <= 2):
		# Informa o usuario como utilizar o programa.
		print(f"\nCOMO USAR?\n\t{sys.argv[0]} CDKEY_16 CDKEY_2\n")

		# * Se a quantidade de argumentos recebidos for igual a 2, 
		# * significa que o usuario informou a primeira parte da 
		# * CDKEY, apenas. Por isso, sera necessario calcular os digitos 
		# * finais.
		if (argc == 2):
			if (len(sys.argv[1]) == 16):
				strKey1Input = sys.argv[1]
			else:
				print(" * ERRO: CDKEY invalida!\n ** Tamanho incorreto da CD_KEY_16.\n")
				sys.exit(1)
		else:
			# * Caso o usuario nao tenha informado nenhum dos argumentos,
			# * o programa devera gerar uma CDKey aleatoria.
			# * Atribuir a CDKey gerada no programa.
			strKey1Input = GerarKeyRandomica()

		# * Os ultimos digitos da CDKey sao calculados com base na CDKEY1
		# * informada, ou na string gerada aleatoriamente. */
		resultadoDigitos = GerarKeyDigitos(strKey1Input)

		print(f"\t======================================");
		print(f"\t= CDKEY gerada: {strKey1Input}  {resultadoDigitos} =");
		print(f"\t======================================\n");

		sys.exit(0)

	# Depois da validacao, atribui-se os valores dos parametros nas variaveis.
	argInput1 = sys.argv[1]
	argInput2 = sys.argv[2]

	# Inicia verificacao da chave informada pelo usuario.
	VerificaKey(argInput1, argInput2)

	# eof   :)